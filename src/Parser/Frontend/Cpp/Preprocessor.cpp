
/*
	preprocessing-file:
		groupopt
	group:
		group-part
		group group-part
	group-part:
		if-section
		control-line
		text-line
		# non-directive
	if-section:
		if-group elif-groupsopt else-groupopt endif-line
	if-group:
		# if constant-expression new-line groupopt
		# ifdef identifier new-line groupopt
		# ifndef identifier new-line groupopt
	elif-groups:
		elif-group
		elif-groups elif-group
	elif-group:
		# elif constant-expression new-line groupopt
	else-group:
		# else new-line groupopt
	endif-line:
		# endif new-line
	control-line:
		# include pp-tokens new-line
		# define identifier replacement-list new-line
		# define identifier lparen identifier-listopt) replacement-list new-line
		# define identifier lparen ... ) replacement-list new-line
		# define identifier lparen identifier-list, ... ) replacement-list new-line
		# undef identifier new-line
		# line pp-tokens new-line
		# error pp-tokensopt new-line
		# pragma pp-tokensopt new-line
		# new-line
	text-line:
		pp-tokensopt new-line

	non-directive:
		pp-tokens new-line
	lparen:
		a ( character not immediately preceded by white-space
	identifier-list:
		identifier
		identifier-list , identifier
	replacement-list:
		pp-tokensopt
	pp-tokens:
		preprocessing-token
		pp-tokens preprocessing-token
	new-line:
		the new-line character

	......
	sizeof
	alignof
	defined ( 識別子 )

	__STDC__


	-----------------------------------
	JISX3014 プログラム言語C++

	16.1
	# 〜キーワード前の間は 空白と水平タブのみ可、だけどとりあえず「空白類」としている。

	16.1注(136)
	制御定数式内の全ての識別子はマクロ名であるか否かのいずれかとなる。
	すなわち、キーワード、列挙定数などはまだ存在しない。
	↓
	キャスト式不可能。


	■ "#if AAA" で AAA が未定義のとき
		> 16.1
		> マクロ展開及び defined 単項演算子による全ての置換の実行後、残っている全ての識別子及び
		> true と false　を除くキーワードを前処理数 0 で置き換えてから、各前処理字句を字句に変換する。
		↓
		未定義マクロ (undef されたものも含む) は #if の条件式で使用でき、値は必ず 0 となる。 

	■ マクロ再定義
		#define CCC 1+1			// オリジナル
		#define CCC 1+1\s		// OK。前後の空白は許可
		#define CCC 1 + 1		// NG。(VisualC++では警告)
		#define CCC 1/＊＊/+1	// NG。(VisualC++では警告)

	■ 置換要素の中に defined があるとき
		#define HHH 1
		#define GGG defined(HHH)
		#if GGG

		未定義動作。VisualStudio では defined として解釈されない。
		ただ、↑の例は結果 0 でエラーにはならない。しかし、defined を aaa のようなほかの識別子とすると警告が発生する。

		本ライブラリとしては通常の識別子扱いし、defined=0で解釈する。
		その結果 0(1) という展開結果になるため式の解析でエラーが出ることになる。
*/
#include "../../Internal.h"
#include "../../DiagnosticsManager.h"
#include "../../ParserUtils.h"
#include "../../UnitFile.h"
#include "CppLexer.h"
#include "Preprocessor.h"

LN_NAMESPACE_BEGIN
namespace parser
{

//=============================================================================
// MacroMap
//=============================================================================

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
//void MacroEntity::AppendReplacementToTokenList(TokenList* tokenList)
//{
//	for (const Token* pos = replacementBegin; pos < replacementEnd; ++pos)
//	{
//		tokenList->Add(*pos);
//	}
//}

//=============================================================================
// MacroMap
//=============================================================================

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
MacroEntity* MacroMap::Insert(const Token& name, const SourceRange& replacementRange)
{
	MacroEntity macro;
	macro.name = name.ToString();
	macro.replacementRange = replacementRange;
	//macro.replacementContentString = TokenString(replacementBegin->GetBegin(), replacementEnd->GetEnd() - replacementBegin->GetBegin());

	m_allMacroList.Add(macro);
	MacroEntity* m = &m_allMacroList.GetLast();
	m_macroMap.Insert(name.GetBegin(), name.GetEnd(), m);
	return m;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
MacroEntity* MacroMap::Find(const Token& name)
{
	MacroEntity* e;
	if (m_macroMap.Find(name.GetBegin(), name.GetEnd(), &e, CaseSensitivity::CaseSensitive))	// TODO: 大文字小文字
		return e;
	else
		return nullptr;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
bool MacroMap::IsDefined(const Token& name, MacroEntity** outDefinedMacro)
{
	MacroEntity* e = Find(name);
	if (e != nullptr)
	{
		if (outDefinedMacro) { *outDefinedMacro = e; }
		return !e->undef;
	}
	return false;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
uint64_t MacroMap::GetHashCode() const
{
	uint64_t value = 0;
	for (auto& macro : m_allMacroList)
	{
		value += Hash::CalcHash(macro.name.c_str(), macro.name.GetLength());
	}
	return value + m_allMacroList.GetCount();	// ついでに個数でもいれておこうか
}

//=============================================================================
// Preprocessor
//=============================================================================

////-----------------------------------------------------------------------------
////
////-----------------------------------------------------------------------------
//SourceRange PreprocessedFileCacheItem::SaveMacroTokens(const Token* begin, const Token* end)
//{
//	SourceRange range;
//	range.begin.loc = m_tokensCache.GetCount();
//	for (const Token* pos = begin; pos < end; ++pos)
//	{
//		m_tokensCache.Add(*pos);
//	}
//	range.end.loc = m_tokensCache.GetCount();
//	m_tokensCache.Add(Token::EofToken);	// Eof を入れておくことでオーバーランや m_tokensCache[range.end.loc] へのアクセスに備える
//	return range;
//}
//
////-----------------------------------------------------------------------------
////
////-----------------------------------------------------------------------------
//void PreprocessedFileCacheItem::GetMacroTokens(const SourceRange& range, const Token** outBegin, const Token** outEnd) const
//{
//	assert(outBegin != nullptr);
//	assert(outEnd != nullptr);
//	*outBegin = &m_tokensCache[range.begin.loc];
//	*outEnd = &m_tokensCache[range.end.loc];
//}
//
//=============================================================================
// Preprocessor
//=============================================================================

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
Preprocessor::Preprocessor()
	: m_tokenList(nullptr)
	, m_unitFile(nullptr)
	, m_seqDirective(DirectiveSec::Idle)
{
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
ResultState Preprocessor::BuildPreprocessedTokenList(TokenList* tokenList, UnitFile* unitFile, DiagnosticsItemSet* diag)
{
	m_tokenList = tokenList;
	m_unitFile = unitFile;
	m_diag = diag;
	m_seqDirective = DirectiveSec::LineHead;
	m_conditionalSectionStack.Clear();

	int tokenCount = m_tokenList->GetCount();
	for (int iToken = 0; iToken < tokenCount; ++iToken)
	{
		Token& token = m_tokenList->GetAt(iToken);

		// プリプロディレクティブ処理中でなければ、トークンの valid は現在の状態に従い、処理中は全て無効扱いにする
		if (m_seqDirective == DirectiveSec::Idle ||
			m_seqDirective == DirectiveSec::LineHead)
		{
			token.SetValid(IsInValidSection());
		}
		else
		{
			token.SetValid(false);
		}

		// 何もしていない。改行を探す。
		if (m_seqDirective == DirectiveSec::Idle)
		{
			if (token.GetCommonType() == CommonTokenType::NewLine)
			{
				m_seqDirective = DirectiveSec::LineHead;		// 改行が見つかった。行頭状態へ
			}
		}
		// 行頭にいる。# を探す。
		else if (m_seqDirective == DirectiveSec::LineHead)
		{
			if (token.GetCommonType() == CommonTokenType::Operator &&
				token.EqualString("#", 1))
			{
				m_seqDirective = DirectiveSec::FindIdent;	// "#" を見つけた。識別子を探す
				token.SetValid(false);						// ディレクティブの解析が始まるタイミングなので、ここからトークンを無効にし始める
			}
			else {
				m_seqDirective = DirectiveSec::Idle;		// "#" 以外のトークンだった。Idle へ。
			}
		}
		// 識別子を探している。
		else if (m_seqDirective == DirectiveSec::FindIdent)
		{
			if (token.IsSpaceOrComment())
			{
				// 続行
			}
			else if (
				token.GetCommonType() == CommonTokenType::Identifier ||
				token.GetCommonType() == CommonTokenType::Keyword)		// #else はキーワードで飛んでくる
			{
				// 見つけた
				m_preproLineHead = &token;
				m_seqDirective = DirectiveSec::FindLineEnd;	// 行末を探しに行く
			}
			else if (
				token.GetCommonType() == CommonTokenType::NewLine ||
				token.GetCommonType() == CommonTokenType::Eof)
			{
				// # しかない行だった。シーケンスを戻す
				m_seqDirective = DirectiveSec::LineHead;
			}
			else
			{
				// Error: # の次になんか変なトークンが来た
				m_diag->Report(DiagnosticsCode::Preprocessor_UnexpectedDirectiveToken, token.ToString());
				return ResultState::Error;
			}
		}
		// 行末を探している。
		else if (m_seqDirective == DirectiveSec::FindLineEnd)
		{
			if (token.GetCommonType() == CommonTokenType::NewLine ||
				token.GetCommonType() == CommonTokenType::Eof)
			{
				LN_RESULT_CALL(PollingDirectiveLine(m_preproLineHead, &token));

				if (token.GetCommonType() == CommonTokenType::NewLine) {
					m_seqDirective = DirectiveSec::LineHead;	// 改行なので行頭状態へ
				}
				else {
					m_seqDirective = DirectiveSec::Idle;
				}
			}
		}
	}
	return ResultState::Success;
}

//-----------------------------------------------------------------------------
// lineBegin は 識別子を指している。#include なら include。
// lineEnd は NewLine か Eof を指している。間に 行末\がある場合は飛ばされている。
//-----------------------------------------------------------------------------
ResultState Preprocessor::PollingDirectiveLine(Token* keyword, Token* lineEnd)
{
	//---------------------------------------------------------
	// #define
	//		:: # define identifier replacement-list new-line
	//		:: # define identifier lparen identifier-listopt) replacement-list new-line
	//		:: # define identifier lparen ... ) replacement-list new-line
	//		:: # define identifier lparen identifier-list, ... ) replacement-list new-line
	if (keyword->EqualString("define", 6))
	{
		// 識別子(マクロ名)まで進める
		Token* macroName = ParserUtils::SkipNextSpaceOrComment(keyword, lineEnd);
		if (macroName->GetCommonType() != CommonTokenType::Identifier)
		{
			// Error: 識別子ではなかった
			m_diag->Report(DiagnosticsCode::Preprocessor_SyntaxError);
			return ResultState::Error;
		}

		// スペースを飛ばす
		Token* parenOrReplacement = ParserUtils::SkipNextSpaceOrComment(keyword, lineEnd);

		// end はスペースがではなくなるまで戻す
		lineEnd = ParserUtils::SkipPrevSpaceOrComment(keyword, lineEnd);

		Token* replacementBegin = nullptr;
		if (parenOrReplacement->GetCommonType() == CommonTokenType::Operator && parenOrReplacement->EqualChar('('))
		{
			// 関数形式だった。識別子を仮引数として取り出す。TODO: , とか見てないけど・・・
			m_funcMacroParams.Clear();
			Token* pos = parenOrReplacement + 1;
			for (; pos < lineEnd; ++pos)
			{
				if (pos->GetCommonType() == CommonTokenType::Operator && pos->EqualChar(')'))
				{
					replacementBegin = ParserUtils::SkipNextSpaceOrComment(pos, lineEnd);
					break;
				}
				else if (pos->GetCommonType() == CommonTokenType::Identifier)
				{
					m_funcMacroParams.Add(pos);
				}
				else if (pos->GetCommonType() == CommonTokenType::Operator && pos->GetLangTokenType() == TT_CppOP_Ellipsis)
				{
					m_funcMacroParams.Add(pos);	// "..."
				}
			}

			// TODO: ) error
		}
		else
		{
			replacementBegin = parenOrReplacement;
		}

		// 定義内容を入力トークンリストから取り出して保持する
		SourceRange range = m_unitFile->SaveMacroReplacementTokens(keyword, lineEnd + 1);

		// マクロ登録
		// TODO: マクロの上書き確認
		m_unitFile->m_macroMap->Insert(*macroName, range);
	}
	//---------------------------------------------------------
	// #if
	//		:: # if constant-expression new-line groupopt
	else if (keyword->EqualString("if", 2))
	{
		LN_RESULT_CALL(AnalyzeIfElif(keyword, lineEnd, false));
	}
	//---------------------------------------------------------
	// #elif
	//		:: # elif constant-expression new-line groupopt
	else if (keyword->EqualString("elif", 4))
	{
		LN_RESULT_CALL(AnalyzeIfElif(keyword, lineEnd, true));
	}
	//---------------------------------------------------------
	// #ifdef
	//		:: # ifdef identifier new-line groupopt
	// #ifndef
	//		:: # ifndef identifier new-line groupopt
	else if (
		keyword->EqualString("ifdef", 5) ||
		keyword->EqualString("ifndef", 6))
	{
		// 新しいセクションを開始する
		m_conditionalSectionStack.Push(ConditionalSection());

		// 次の識別子まで進める
		Token* pos = ParserUtils::SkipNextSpaceOrComment(keyword, lineEnd);
		// Error: 識別子ではなかった
		LN_DIAG_REPORT_ERROR(pos->GetCommonType() == CommonTokenType::Identifier, DiagnosticsCode::Preprocessor_SyntaxError);

		// 現時点でマクロが定義されているかチェック
		bool isDefined = m_unitFile->m_macroMap->IsDefined(*pos);

		// "ifndef" なら条件を反転
		if (keyword->GetLength() == 6) {
			isDefined = !isDefined;
		}

		if (isDefined)
		{
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Valid;
		}
		else
		{
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Invalid;
		}
	}
	//---------------------------------------------------------
	// #else
	//		::	# else new-line groupopt
	else if (keyword->EqualString("else", 4))
	{
		if (m_conditionalSectionStack.IsEmpty() ||				// #if がない
			m_conditionalSectionStack.GetTop().elseProcessed)	// 既に #else 受領済み
		{
			// Error: 予期しない #else
			m_diag->Report(DiagnosticsCode::Preprocessor_UnexpectedElse);
			return ResultState::Error;
		}

		if (m_conditionalSectionStack.GetTop().state == ConditionalSectionState::Valid)
		{
			// 有効領域のあとの #else なので、後は何があろうと全て無効領域となる
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Skip;
		}
		else if (m_conditionalSectionStack.GetTop().state == ConditionalSectionState::Invalid)
		{
			// いままで無効だったのでここから有効になる
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Valid;
		}
		else
		{
			// Skip のまま維持する
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Skip;
		}

		// else を処理した
		m_conditionalSectionStack.GetTop().elseProcessed = true;
	}
	//---------------------------------------------------------
	// #endif
	//		::	# endif new-line
	else if (keyword->EqualString("endif", 5))
	{
		if (m_conditionalSectionStack.IsEmpty())
		{
			// Error: 予期しない #endif
			m_diag->Report(DiagnosticsCode::Preprocessor_UnexpectedEndif);
			return ResultState::Error;
		}
		m_conditionalSectionStack.Pop();
	}
	//---------------------------------------------------------
	// #line
	//		::	# line pp-tokens new-line
	else if (keyword->EqualString("line", 4))
	{
		// TODO:
	}

	return ResultState::Success;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
ResultState Preprocessor::AnalyzeIfElif(Token* keyword, Token* lineEnd, bool isElse)
{
	// #if の場合
	if (!isElse)
	{
		// 新しいセクションを開始する
		m_conditionalSectionStack.Push(ConditionalSection());
	}
	// #elif の場合
	else
	{
		if (m_conditionalSectionStack.IsEmpty() ||				// #if がない
			m_conditionalSectionStack.GetTop().elseProcessed)	// 既に #else 受領済み
		{
			LN_DIAG_REPORT_ERROR(0, DiagnosticsCode::Preprocessor_UnexpectedElif);
		}

		if (m_conditionalSectionStack.GetTop().state == ConditionalSectionState::Valid)
		{
			// 有効領域のあとの #else なので、後は何があろうと全て無効領域となる
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Skip;
			return ResultState::Success;
		}
		else if (m_conditionalSectionStack.GetTop().state == ConditionalSectionState::Skip)
		{
			// 既に Skip 状態
			return ResultState::Success;
		}
	}

	// スペースを飛ばす
	Token* pos = ParserUtils::SkipNextSpaceOrComment(keyword, lineEnd);

	// Error: 定数式が無かった
	LN_DIAG_REPORT_ERROR(pos < lineEnd, DiagnosticsCode::Preprocessor_InvalidConstantExpression);

	// 定数式内のマクロを展開して RpnParser に掛けるためのトークンリストを作る
	m_preproExprTokenList.Clear();
	m_preproExprTokenList.Reserve(lineEnd - pos);		// マクロ展開で増えることはあるが、とりあえずこれだけあらかじめ確保しておく
	for (; pos < lineEnd;)
	{
		if (pos->GetCommonType() == CommonTokenType::Identifier)
		{
			MacroEntity* definedMacro;

			// defined ならその処理へ
			if (pos->EqualString("defined", 7))
			{
				Token* ident = nullptr;

				// スペースを飛ばす
				pos = ParserUtils::SkipNextSpaceOrComment(pos, lineEnd);
				if (pos->GetCommonType() == CommonTokenType::Identifier)
				{
					// 識別子だった。"#if defined AAA" のような形式。
					ident = pos;
				}
				else if (pos->GetCommonType() == CommonTokenType::Operator && pos->EqualChar('('))
				{
					// ( だった。さらに飛ばすと識別子、もうひとつ飛ばすと ')'
					ident = ParserUtils::SkipNextSpaceOrComment(pos, lineEnd);
					LN_DIAG_REPORT_ERROR(ident->GetCommonType() == CommonTokenType::Identifier, DiagnosticsCode::Preprocessor_ExpectedDefinedId);
					Token* paren = ParserUtils::SkipNextSpaceOrComment(ident, lineEnd);
					LN_DIAG_REPORT_ERROR(paren->GetCommonType() == CommonTokenType::Operator && paren->EqualChar(')'), DiagnosticsCode::Preprocessor_ExpectedDefinedId);
					++pos;
					++pos;
				}
				else
				{
					// Error: defined の後に識別子が必要
					LN_DIAG_REPORT_ERROR(0, DiagnosticsCode::Preprocessor_ExpectedDefinedId);
				}

				// マクロを探す
				if (m_unitFile->m_macroMap->IsDefined(*ident)) {
					m_preproExprTokenList.Add(m_constTokenBuffer.Get1());	// "1" に展開
				}
				else {
					m_preproExprTokenList.Add(m_constTokenBuffer.Get0());	// "0" に展開
				}
				++pos;
			}
			// TODO: C++特有。CではNG?
			else if (pos->EqualString("true", 4))
			{
				m_preproExprTokenList.Add(m_constTokenBuffer.Get1());	// "1" に展開
				++pos;
			}
			// マクロかも
			else if (m_unitFile->m_macroMap->IsDefined(*pos, &definedMacro))
			{
				const Token* begin;
				const Token* end;
				m_unitFile->GetMacroReplacementTokens(definedMacro->replacementRange, &begin, &end);
				for (; begin < end; ++begin) {
					m_preproExprTokenList.Add(*begin);
				}
				//definedMacro->AppendReplacementToTokenList(&m_preproExprTokenList);
				++pos;
			}
			// それ以外のただの識別子はすべて 0 にしなければならない
			else
			{
				m_preproExprTokenList.Add(m_constTokenBuffer.Get0());	// "0" に展開
				++pos;
			}
		}
		else
		{
			m_preproExprTokenList.Add(*pos);
			++pos;
		}
	}

	// 定数式を評価する
	LN_RESULT_CALL(m_rpnParser.ParseCppConstExpression2(m_preproExprTokenList.cbegin(), m_preproExprTokenList.cend(), m_diag));
	RpnOperand result;
	LN_RESULT_CALL(m_rpnEvaluator.TryEval(m_rpnParser.GetTokenList(), m_diag, &result));

	// 整数型と bool を許可
	if (result.IsIntager() || result.type == RpnOperandType::Boolean)
	{
		if (result.IsFuzzyTrue()) {	// 0 以外または true
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Valid;
		}
		else {
			m_conditionalSectionStack.GetTop().state = ConditionalSectionState::Invalid;
		}
	}
	else
	{
		// Error: 整数定数式が必要です
		LN_DIAG_REPORT_ERROR(pos < lineEnd, DiagnosticsCode::Preprocessor_InvalidConstantExpression);
	}

	return ResultState::Success;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
bool Preprocessor::IsInValidSection() const
{
	if (m_conditionalSectionStack.IsEmpty()) {
		return true;
	}
	else if (m_conditionalSectionStack.GetTop().state == ConditionalSectionState::Valid) {
		return true;
	}
	return false;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
//TokenList::iterator Preprocessor::GetNextGenericToken(TokenList::iterator pos)
//{
//	while (!pos->IsEof())
//	{
//		++pos;
//		if (pos->GetCommonType() != CommonTokenType::SpaceSequence &&
//			pos->GetCommonType() != CommonTokenType::Comment)
//		{
//			return pos;
//		}
//	}
//	return pos;
//}

} // namespace Parser
LN_NAMESPACE_END

